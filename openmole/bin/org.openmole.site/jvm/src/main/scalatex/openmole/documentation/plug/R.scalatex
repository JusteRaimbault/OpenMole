@import org.openmole.site.tools._
@import org.openmole.site._
@import org.openmole.site.content.Native._
@import DocumentationPages._



@h2{RTask}

@aa("R", href := shared.link.rcran) is a scripted language initially designed for statistics, but whose application range is much broader today (for example GIS, operational research, linear algebra, web applications, etc.), thanks to its large community and the variety of packages.
It may be convenient to use specific R libraries within a workflow, and therefore OpenMOLE provides a specific @code{RTask}.


@h3{Preliminary remark}

@usesSingularity("RTask")


@h3{RTask syntax}

The @code{RTask} relies on an underlying @code{ContainerTask} but is designed to be transparent and takes only R-related arguments.
The current version of R used is @shared.rTask.rVersion.
It takes the following arguments :

@ul
   @li{@code{script} String, @b{mandatory}. The R script to be executed, either R code directly or a R script file.}
   @li{@code{install} Sequence of strings, @b{optional} (default = empty). The commands to be executed prior to any R packages installation and R script execution (see example below: some R libraries may have system dependencies, that have to be installed first).}
   @li{@code{libraries} Sequence of strings, @b{optional} (default = empty). The name of R libraries that will be used by the script and need to be installed beforehand (note: as detailed below, installations are only done during the first execution of the R script, and then stored in a cached docker image. To force an update, use the @i{forceUpdate} argument).}
   @li{@code{forceUpdate} Boolean, @b{optional} (default = @code{false}). Should the libraries installation be forced (to ensure an update for example). If @code{true}, the task will perform the installation (and thus the update) even if the library was already installed.}

@br

The following properties must be defined using @code{set}:

@ul
   @li{@code{input/output} similar to any other task,}
   @li{mapped input: the syntax @code{inputs += om-variable mapped "r-variable"} establishes a link between the workflow variable @code{om-variable} (Val) and the corresponding R variable named @code{r-variable} (as a String).
   If variables have the same name, you can use the short syntax @code{inputs += my-variable.mapped},}
   @li{mapped output: similar syntax as inputs to collect outputs of the model.}

@br

We develop below a detailed example of how to use a @code{RTask}, from a very simple use case to a more elaborate one, with system libraries and R libraries.



@h2{Example 1: A simple @code{RTask}}

The toy R script for this first test case is the following:

@br@br

@hl("""
    f <- function(x) {
        x + 1
    }
""", "R")

@br

This scripts creates a function @code{f} that takes a parameter (a number) and adds 1 to it.
We save this to a file named @i{Rscript1.R} in our OpenMOLE workspace.


@h3{Write and execute R code}

For our first example, we write the R script directly in the @code{RTask}.

@br@br

@openmole(s"""
    // Task
    val rTask1 = RTask($tq
        # Here you write your R code

        # Define the function
        f <- function(x) {
            x + 1
        }

        # Use the function
        j <- f(2)
    $tq)

    // Workflow
    rTask1
""")

@br

Since we don't provide any output variable in which to store the result of the function execution @code{j}, and we don't use a hook either, nothing is returned.
However, we can see that the workflow is executed properly.


@h3{Running a script from a file}

Instead of writing the R code in the @code{RTask}, we can call an external R script containing the code to be executed.
We will use the file @i{Rscript1.R} created earlier.
It needs to be uploaded in the OpenMOLE workspace.

@br

In order to use the R script, we need to provide the @code{resources} field with the precise location of the file in our work directory.
It will then be imported in the @code{RTask} by the R primitive @code{source()}).

@br@br

@openmole( s"""
    // Task
    val rTask2 = RTask($tq
        # Import the external R script
        source("Rscript1.R")

        # Use the f function from the script
        j <- f(2)
    $tq) set (
        resources += (workDirectory / "Rscript1.R")
    )

    // Workflow
    rTask2
    """)

@br

Since we don't provide any output variable in which to store the result of the function execution @code{j}, and we don't use a hook either, nothing is returned.
However, we can see that the workflow is executed properly.


@h3{Input and output values}

We want to be able to define inputs to the @code{RTask} externally, and to store the output values.

@h6{Mapped values}
It is possible to do so through the @code{inputs} and @code{outputs} parameters in the @code{set} part of the task.

@br@br

@openmole( s"""
    // Declare variables
    val myInput = Val[Int]
    val myOutput = Val[Int]

    // Task
    val rTask3 = RTask($tq
        # Define the function
        f <- function(x) {
            x + 1
        }

        # Use the function
        j <- f(i)
    $tq) set (
        inputs += myInput mapped "i",
        outputs += myOutput mapped "j",

        // Default value for the input
        myInput := 3
    )

    // Workflow
    rTask3 hook display
""")

@br

Here, @code{i} and @code{j} are R variables defined and used in the R code, while @code{myInput} and @code{myOutput} are OpenMOLE variables.
The syntax @code{om-variable mapped "r-variable"} creates a link between the two, indicating that these should be considered the same in the workflow.

@br@br

If your OpenMOLE variable and R variable have the same name (say @code{my-variable} for instance), you can use the following shortcut syntax: @code{my-variable.mapped}.

@h6{Combine mapped and classic inputs/outputs}
If you have several outputs, you can combine mapped outputs with classic outputs that are not part of the @code{RTask}:

@br@br

@openmole( s"""
    // Declare variables
    val i = Val[Int]
    val j = Val[Double]
    val c = Val[Double]

    // Task
    val rTask4 =
    RTask($tq
        # Define the function
        f <- function(x) {
            x + 1
        }

        # Use the function
        j <- f(i)
    $tq) set (
        (inputs, outputs) += c,
        inputs += i.mapped,
        outputs += i, // i don't need to be mapped again, it was done just above
        outputs += j.mapped,

        // Default values
        c := 2,
        i := 3
    )

    // Workflow
    rTask4 hook display
""")

@br

This technique can be used when you have a chain of tasks and you want to use a hook.
Indeed, the hook only captures outputs of the last executed task, thus we can add a variable of interest in the output of the task even if it does not appear in this task.



@h2{Example 2: Working with files}

It is possible to use files as arguments of a @code{RTask}.
The @code{inputFiles} keyword is used.
We emphasize that @code{inputFiles} is different from @code{resources}, which was used to import external R scripts.
@code{inputFiles} is used as a @code{Val} and can be acted upon in a workflow.

@br@br

In this example workflow, we first have a @code{ScalaTask} writing numbers in a file.
The file is created through the OpenMOLE variable @code{myFile} of type @i{java.io.File}.
In order to have access to this file in the @code{RTask}, we add @code{myFile} as an output of the @code{ScalaTask} and an input of the @code{RTask}.
@br
The R script in the @code{RTask} reads a file named @i{fileForR.txt} (in the R script presented here, it is supposed to have numeric values, separated by a simple space), and creates a R variable @code{myVector}, which is a vector containing the value of the file @i{fileForR.txt}.
We then apply the function @code{f} to that vector.
@br
The end of the workflow simply tells OpenMOLE to chain the two tasks and to display the outputs of the last task (here the OpenMOLE variable @code{resR}).

@br@br

@openmole( s"""
    // Declare variable
    val myFile = Val[File]

    // Task
    val task1 = ScalaTask($tq
        val myFile = newFile()
        myFile.content = "3 6 4"
    $tq) set (
        outputs += myFile
    )

    /////////////////////////////

    // Declare variable
    val resR = Val[Array[Double]]

    // Task
    val rTask = RTask($tq
        myData <- read.table("fileForR.txt", sep = " ")
        myVector <- as.vector(myData, mode = "numeric")

        f <- function(x) {
            x + 1
        }

        k <- f(myVector)
    $tq) set(
        inputFiles += (myFile, "fileForR.txt"),
        outputs += resR mapped "k"
    )

    // Workflow
    task1 -- (rTask hook display)
""")

@br

Note that @code{g} is an OpenMOLE variable created on the fly during execution and which is deleted afterward.
If you want to see this file you need to save it to your workspace by using a @a("hook", href := hook.file + "#Hooktocopyafile").



@h2{Example 3: Use a library}

Here we give an example of how to use a library in an @code{RTask}.
We use the function @code{CHullArea} of the library @code{GeoRange} to compute the area in the convex envelop of a set of points.

@br@br

Write the names of the libraries you need in the field @code{libraries}, and adapt the @code{install} field accordingly.
The @code{install} argument is a sequence of system commands which are executed prior to the installation of the R libraries.
It can be used to install the packages which are required by the R libraries.
The @code{RTask} is based on a Debian container, therefore you can use any Debian command here including @code{apt} installation tool.

@br

The @code{libraries} argument is a sequence of libraries that are installed from the CRAN repository.

@br@br

Note: the first time you use R with @code{libraries} or @code{packages}, it takes some time to install them, but for the next uses those libraries will be stored, and the execution will be quicker.

@br@br

@openmole( s"""
    // Declare variable
    val area = Val[Double]

    // Task
    val rTask3 = RTask($tq
        library(GeoRange)

        n <- 40
        x <- rexp(n, 5)
        y <- rexp(n, 5)

        # To have the convex envelop of the set of points we created
        liste <- chull(x, y)
        hull <- cbind(x, y) [liste,]

        # require GeoRange
        area <- CHullArea(hull[, 1], hull[, 2])
        $tq,
        install = Seq("apt-get update", "apt-get install -y libgdal-dev libproj-dev"),
        libraries = Seq("GeoRange")
    ) set(
        outputs += area.mapped
    )

    // Workflow
    rTask3 hook display
""")



@h2{Example 4: A complete workflow}

Here is an example of a use case workflow using a @code{RTask}.
It takes advantage of @code{rInputs}, @code{inputFiles}, and @code{install}.
You could add your R script using @code{resource}.

@br@br

The first task is a @code{ScalaTask} whose aim is to create OpenMOLE variables that will be used in the @code{RTask}.
We provide them to the @code{RTask} using @code{inputFiles} and @code{inputs} keywords.

@br

Notice that the conversion from the OpenMOLE type (Scala) @code{Array[Double]} to the R type vector is made directly by @code{inputs}.

@br

The hook stores the file @code{g} in your workspace} and displays the @code{area}.

@br@br

@openmole( s"""
    // Declare variables
    val n = Val[Int]
    val myFile = Val[File]
    val y = Val[Array[Double]]
    val res = Val[Double]

    val mySeed = Val[Long]

    // Scala task
    val task1 = ScalaTask($tq
        val rng = Random(mySeed)

        val dist1 = List.fill(n)(rng.nextDouble).mkString(" ")

        val myFile = newFile()
        myFile.content = dist1

        val y = List.fill(n)(rng.nextDouble).toArray
    $tq) set(
        (inputs, outputs) += (n, mySeed),
        outputs += (myFile, y),

        // Default value
        n := 10
    )

    // R task
    val rTask = RTask($tq
        library(GeoRange)

        n <- 40
        x <- rexp(n, 5)
        y <- rexp(n, 5)

        # To have the convex envelop of the set of points we created
        liste <- chull(x, y)
        hull <- cbind(x, y) [liste,]

        # require GeoRange
        area <- CHullArea(hull[, 1], hull[, 2])
        $tq,
        install = Seq("apt-get update", "apt-get install -y libgdal-dev libproj-dev"),
        libraries = Seq("GeoRange")
    ) set(
        (inputs, outputs) += (n, mySeed),
        inputs += myFile mapped "fileForR",
        inputs += y.mapped,
        outputs += myFile,
        outputs += res mapped "area"
    )

    // Define hook
    val h1 = CopyFileHook(myFile, workDirectory / "random_points_$${mySeed}.txt")

    // Workflow
    Replication(
        evaluation = task1 -- (rTask hook h1),
        seed = mySeed,
        sample = 100
    )
""")


@h2{Advanced RTask: use a library within docker}

If you are starting openmole within docker, installing @code{R} packages in a @code{RTask} might require a slighlty different parameter setting.
If you compare our example below with the example of library above, you'll observe differences in the @code{install} field: we prefix install commands with @code{fakeroot} 
to get the permissions to use the Debian command @code{apt} for installation. 

@br@br

@openmole( s"""
    // Declare variable
    val area = Val[Double]

    // Task
    val rTask3 = RTask($tq
        library(GeoRange)

        n <- 40
        x <- rexp(n, 5)
        y <- rexp(n, 5)

        # To have the convex envelop of the set of points we created
        liste <- chull(x, y)
        hull <- cbind(x, y) [liste,]

        # require GeoRange
        area <- CHullArea(hull[, 1], hull[, 2])
        $tq,
        install = Seq("fakeroot apt-get update", "fakeroot apt-get install -y libgdal-dev libproj-dev"),
        libraries = Seq("GeoRange")
    ) set(
        outputs += area.mapped
    )

    // Workflow
    rTask3 hook display
""")


@h2{Advanced RTask: usage of HTTP proxy}

If you start openmole behind a HTTP proxy, you are probably familar already with the @code{--proxy} parameter you can add to the OpenMole command line, 
which makes OpenMole use your proxy when downloading anything from the web. You can use it like @code{openmole --proxy http://myproxy:3128}. 
This proxy will also be used by OpenMole to download any container, including the containers used behing the curtain to run a @code{RTask}.
This proxy will also be used by the @code{RTask} to download packages from the web. 

@h2{Advanced RTask: use alternative debian repositories}

We show how using the @code{install} parameter of a @code{RTask} enables to use Debian installation tools such as @code{apt} to install packages 
in the container running \code{R}.
This downloads debian packages from the default international repositories (servers) for Debian.
In some cases, you might be willing to use alternative repositories. 

@br@br

A first reason might be sleep: download and installation of packages might require hundreds of megabytes of download, leading to an important consumption of data and a slower construction of the container
(only at the first execution, as the container is reused for further executions).
If you institution is running a local Debian repository, you would save data and time by using this repository. 
You might also need packages which are not part of the default Debian repositories. 

@br@br

You can do so by doing a smart usage of the @code{install} parameter to define your own repositories as shown in the example below. 


@br@br

@openmole( s"""
    // Declare variable
    val area = Val[Double]

    // Task
    val rTask3 = RTask($tq
        library(ggplot2)
        library(gganimate)
      
        # your R script here 
        # [...]
        $tq,
        install = Seq(
           // replace the initial Debian repositories by my repository
           "fakeroot sed -i 's/deb.debian.org/linux.myinstitute.org/g' /etc/apt/sources.list",
           // display the list on the console so I can double check what happens
           "fakeroot cat /etc/apt/sources.list",
           // update the list of available packages (here I disable HTTP proxy as this repository is in my network)
           "fakeroot apt-get -o Acquire::http::proxy=false update ",
           // install required R packages in their binary version (quicker, much stable!)
           "DEBIAN_FRONTEND=noninteractive fakeroot apt-get -o Acquire::http::proxy=false install -y r-cran-ggplot2",
           "DEBIAN_FRONTEND=noninteractive fakeroot apt-get -o Acquire::http::proxy=false install -y r-cran-gganimate",
           "DEBIAN_FRONTEND=noninteractive fakeroot apt-get -o Acquire::http::proxy=false install -y r-cran-plotly",
           "DEBIAN_FRONTEND=noninteractive fakeroot apt-get -o Acquire::http::proxy=false install -y r-cran-ggally",
           // install the libs required for the compilation of R packages
           "DEBIAN_FRONTEND=noninteractive fakeroot apt-get -o Acquire::http::proxy=false install -y libssl-dev libcurl4-openssl-dev libudunits2-dev",
           // install ffmpeg to render videos 
           "DEBIAN_FRONTEND=noninteractive fakeroot apt-get -o Acquire::http::proxy=false install -y ffmpeg"
           ), //  
        libraries = Seq("ggplot2", "gganimate", "plotly", "GGally")
    ) set(
        outputs += area.mapped
    )
""")



