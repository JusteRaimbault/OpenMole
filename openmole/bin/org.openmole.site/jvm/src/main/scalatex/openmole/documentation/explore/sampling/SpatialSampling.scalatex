
@import org.openmole.site._
@import org.openmole.site.tools._
@import DocumentationPages._



Geosimulation models, in the broad sense of simulation models in which the spatial configuration of agents plays a significant roles in the underlying processes (think e.g. of spatial interaction models), are generally tested for sensitivity on processes or agents parameters, but less frequently on the spatial configuration itself.
A recent @aa("paper", href:= "http://jasss.soc.surrey.ac.uk/22/4/10.html") proposed the generation of synthetic spatial configurations as a method to test the sensitivity of geosimulation models to the initial spatial configuration.
Some complementary work (@aa("paper", href:= "https://www.mitpressjournals.org/doi/abs/10.1162/isal_a_00159")) focused on similar generator at larger scales, namely generators for building configurations at the scale of the district.

@br

More generally, the @aa("spatial data library", href:= "https://github.com/openmole/spatialdata") developed by the OpenMOLE team integrates these kind of methods in a larger context, including for example synthetic spatial networks and perturbation of real data, but also spatial interaction models and urban dynamics models.

@br

Some of the corresponding spatial generators are included in OpenMOLE as @i{Spatial Samplings}.
In the current development version, only some grid generators are included, for a reason of types for output prototypes (synthetic networks are difficult to represent as simple types and to feed as inputs to models).
All generators output the generated grids in a provided prototype, along with the generation parameters for the generators taking factors as arguments.



@h2{Random grid sampling}

A raster with random values:

@br@br

@hl.openmole("""
val myGrid = Val[Array[Array[Double]]]
val myDensity = Val[Double]

RandomSpatialSampling(
  grid = myGrid,
  sample = 10,
  gridSize = 10,
  density = myDensity in (0.0, 1.0)
)
""", name= "random grid sampling")

@br

where

@ul
  @li{@code{samples} is the number of grids to generate,}
  @li{@code{worldSize} is the width of the generated square grid,}
  @li{the factor for a density parameter is optional and produces a binary grid of given density in average if provided,}
  @li{@code{prototype} is the prototype for the generated grid (must be a @code{Val[Array[Array[Double]]]} since the grid is represented as raster data).}



@h2{Blocks grid sampling}

A binary grid with random blocks (random size and position). With the same arguments as before, except the factors for the generator parameters: @code{blocksNumber} is the number of blocks positioned, @code{blocksMinSize}/@code{blocksMaxSize} minimal/maximal (exchanged if needed) width/height of blocks, each being uniformly drawn for each block.

@br@br

@hl.openmole("""
val myGrid = Val[Array[Array[Double]]]
val myBlocksNumber = Val[Double]
val myBlocksMinSize = Val[Double]
val myBlocksMaxSize = Val[Double]

BlocksGridSpatialSampling(
  grid = myGrid,
  sample = 10,
  gridSize = 10,
  number = myBlocksNumber in (1.0, 20.0),
  minSize = myBlocksMinSize in (1.0, 10.0),
  maxSize = myBlocksMaxSize in (2.0, 30.0)
)
""", name="block grid sampling")


@h2{Thresholded exponential mixture sampling}

A binary grid created with an exponential mixture, with kernels of the form @code{exp(-r/r0)}. A threshold parameter is applied to produce the binary grid.

@br@br

@hl.openmole("""
val myGrid = Val[Array[Array[Double]]]
val myCenter = Val[Double]
val myRadius = Val[Double]
val myThreshold = Val[Double]

ExpMixtureThresholdSpatialSampling(
  grid = myGrid,
  sample = 10,
  worldSize = 10,
  center = myCenter in (1.0, 20.0),
  radius = myRadius in (1.0,10.0),
  threshold = myThreshold in (2.0,30.0)
)
""", name="block grid sampling")

@br

with the specific parameters as factors for generator parameters:

@ul
  @li{@code{center} the number of kernels,}
  @li{@code{radius} the range of kernels,}
  @li{@code{threshold} the threshold to produce the binary grid.}

@h2{Percolated grid sampling}

@b{USE WITH CAUTION - SOME PARAMETER VALUES YIELD VERY LONG GENERATION RUNTIME}

@br

A binary grid resembling a labyrinthine building organisation, obtained by percolating a grid network (see details in @aa("paper", href:= "https://www.mitpressjournals.org/doi/abs/10.1162/isal_a_00159")).
It percolates a grid network until a fixed number of points on the boundaries of the world are linked through the giant cluster.
The resulting network is transposed to a building configuration by assimilating each link to a street with a given width as a parameter.

@br@br

@hl.openmole("""
val myGrid = Val[Array[Array[Double]]]
val myPercolation = Val[Double]
val myBordPoint = Val[Double]
val myLinkWidth = Val[Double]

PercolationGridSpatialSampling(
  grid = myGrid,
  sample = 10,
  gridSize = 10,
  percolation = myPercolation in (0.1, 1.0),
  bordPoint = myBordPoint in (1.0, 30.0),
  linkWidth = myLinkWidth in (1.0, 5.0)
)
""", name="percolation grid sampling")

@br

with

@ul
  @li{@code{percolation} the percolation probability,}
  @li{@code{bordPoint} the number of points on the bord of the grid to belong to the giant cluster,}
  @li{@code{linkWidth} the width of the final streets.}


@h2{Exponential mixture population grid sampling}

At a smaller scale than the previous generators which are all binary grids (building configurations), population density grids can be considered at the metropolitan scale for example (a grid cell being of width 1km for example).

@br

A first simple generator for polycentric population densities uses an exponential mixture:

@br@br

@hl.openmole("""
ExponentialMixtureSpatialSampling(
  gridSize,
  centersNumber,
  maxValue,
  kernelRadius,
  samples,
  prototypes
)
""", name="exp mixture grid sampling")

@br

where

@ul
  @li{@code{gridSize} is the dimension of the world as @code{Either[Int, (Int, Int)]},}
  @li{@code{centersNumber} is an integer giving the number of kernels,}
  @li{@code{maxValue} is optional (default to 1) and can be either a double giving the intensity at the center of each kernel, or a sequence of doubles giving the intensity for each kernel,}
  @li{@code{kernelRadius} is also optional and specifies similarly either all radius or the sequence of radius,}
  @li{@code{samples} is the number of grids to generate,}
  @li{@code{prototypes} is an arbitrary number of prototypes for the generated layers (must be of the same size as provided parameters if in sequence mode).} */

@h2{Reaction diffusion population grid sampling}

Urban morphogenesis model for population density introduced by @aa("(Raimbault, 2018)", href:= "https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0203516").

@br

@b{USE WITH CAUTION - SOME PARAMETER VALUES YIELD VERY LONG GENERATION RUNTIME}

@br@br

@hl.openmole("""
val myGrid = Val[Array[Array[Double]]]

ReactionDiffusionSpatialSampling(
  samples = 10,
  gridSize = 10,
  grid = myGrid,
  alpha = 10.0,
  beta = 10.0,
  nBeta = 10,
  growthRate = 10.0,
  totalPopulation = 10
)
""", name="reaction diffusion grid sampling")

@br

with

@ul
  @li{@code{samples} number of grids to generate,}
  @li{@code{gridSize} width of the square grid,}
  @li{@code{prototype} the prototype for the generated grid,}
  @li{@code{alpha} strength of preferential attachment,}
  @li{@code{beta} strength of diffusion,}
  @li{@code{nBeta} number of times diffusion is operated at each time step,}
  @li{@code{growthRate} number of population added at each step,}
  @li{@code{totalPopulation} the final total population.}



@h2{OpenStreetMap buildings sampling}

@i{Currently being implemented}
